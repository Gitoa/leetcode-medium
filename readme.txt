2.注意构造函数的用法，链表节点的申请

3.map的用法，count/find/erase，count计算出现次数，0或者1，find返回位置，erase删除iterator，M.erase(iter++)，注意提前保存变量，防止之后删除了而不自知

5.双指针，最长回文子串，假设pos1-pos2之间为回文串，更新时判断pos1-1与pos2+1是否相同，相同则加入，否则停止。从0-n-1遍历，初始时pos1=pos2，若pos2+1与pos1相同，加入，更新pos2=po2+1

6.记录下各个字符的二维坐标(x,y)，然后根据坐标排序即可。char与string之间的转换。还有string的方法，找子串，str.find(substr, pos)，从pos开始查找substr，返回首位下标，找不到返回string::npos，substr方法，str.substr(start,length)，str.substring(start, end)

8.太多细节了。注意str.substr(start, length)

11.sort函数自定义比较函数时的注意事项？return x<y;  if(x<y)return true ;else reutn false;第二种方式在数据量大时（999）会出错，不知道什么原因。。。

12.很傻的if else题，注意的方法有string的insert方法，str.insert(pos, substr)

15.3sum，有点麻烦，思考下vector对自定义数据的查找，set.inserst()，对自定义数据去重？vector的元素查找,find(v.begin(), v.end(), val)。最后过了311/313，剩下两个超时了。
采用双指针，复杂度降为on2

16.3sum-closest,和15一样，排序后，利用性质，利用双指针，复杂度为o(n2)。注意的是vector的拷贝初始化， vector<int> tmp(v1)      v.assign(v1.begin(), v2.begin())

17.需要动态增长。注意的知识点？？？单个char转string， 先声明一个string str; str.push_back(char)；vector的赋值,assign，vector清空，v.clear()。

18.4sum。基本思路与3sum一致，排序后，利用性质，利用双指针，复杂度为o(n3)。居然能过。。。

19.最经典的two pointer，删除链表节点中倒数第N个节点，链表删除需要节点的前一个节点，注意的一点是当删除的为head时需要另加判断。

22.和17题类似，不断递增，同时依据题意添加判断条件，保存某次结果，下一次计算需要在上一次的结果上进行遍历增加。涉及知识点？还是char和string的关系吧。另外还有next_permutation的用法，int a[]; while(next_premutation(a,a+10));

24.链表题，简单。。。在稿纸上画好流程图就行

29.不用已有的乘法除法求模操作进行除法计算，暴力相减法在除数很小被除数很大时会超时。利用位运算来代替乘法，且相当于将商表示成二进制形式，若dividend>=divisor<<i，说明第i位为1，商加上2^i。

31.今日头条面试原题，求下一全排列，就是寻找排序大于当前排列且临当前排列最近的一项。交换的位数越低，越接近，因此从右（低位）开始查找，找到第一个i，i的低位有比i上数字更大的数，易得i右侧为递减数列，然后从右侧比i大的数中最小的那位，与i想换，此时i位右侧仍热为递减数列，进行翻转即可。

33.数列为有序数列在某位旋转后得到，查询方法时间复杂度为logn，考虑二分法。每次查找mid=(left+right)/2，若mid为所求位，返回。否则比较left和mid-1, mid+1和right。可以判断左右数列是否有序，若有序，就用有序二分法查找，无序则继续当前方式。

34.也是有序数列二分法查找，查找某个数最初和最后出现的位置，其实只要先找到任意一个等于目标的位置，因为有序，必然相等的数是连续的，利用该性质向左，向右查找即可。

36.判断是否满足数独条件，拆分成几个情况，这样比较好写。注意各个类型的初始化？？？

39.递归加回溯法，需要熟悉下。以及c++的类需要再复习下。

40.同39基本一样，就是不能重复，递归时注意条件。

43.华为面试时问的题。。。大数相乘问题，用字符串保存。分解成单个字符串与整形数相乘，两个字符串相加。注意string的各种转换。华为面试时提到了优化方法，二分法类似，感觉太麻烦了。。。

<<<<<<< HEAD
46.permutation.作弊方法直接用next_permutation()，但是要注意next_permutation前进行下排序，它只会返回在初始值之后的permutation。个人实现采用了递归，主要的话，注意容器的erase和insert方法。

47.作弊方法直接用set。正常解法就是利用相同的数不进行交换的思路。
=======
46.permutation.作弊方法直接用next_permutation()，但是要注意next_permutation前进行下排序，它只会返回在初始值之后的permutation。个人实现采用了递归，主要的话，注意容器的erase和insert方法。v.insert(v.begin()+i, num)。递归其实是DFS的，DFS用标记记录是否加入，我直接在传入时去掉了已加入的数字。此外还有采用swap的方法。

47.permutation.此时有重复数字，用DFS方法做，注意两点。1.保证已经入列的数不再入列（指同一个数，不是相等数），可以用visited数组标记。2.保证在相等的数不会重复出现在同一个位置，可以通过排序，根据num[i]==num[i+1]来判断相等，同时前面的数总是先插入的，若visited[i]==0,说明i已经在该位判断过，不需要再将i+1进行操作。

48.数组旋转，按照题目要求空间复杂度是0？作弊的话直接申请个vector<vector<int>>就可以了。符合标准的解法，观察后发现就是把第i行换成第n-i列，从尾行开始操作，尾行的元素应该作为第一列，在头部插入，倒数第二行应该在第二列插入，依次类推，插入时要判断当前行元素是原来的元素还是插入的。知识点的话？v.insert(v.begin(), nums)
>>>>>>> 81cacd30f3a4605b5e3bc05bec64c340cc8b81b9

49.蛮简单的，暴力方法能过99%的case。使用map后过了，其实主要思想还是一致的，就是在查找时map更快了。（学习一下map是怎么实现的？）

50.蛮简单的，暴力是不可能的，用位运算，把n看成二进制形式，则非0位的值需要相乘，而非0位的底数可以根据上一位的底数得到。注意的就是int型的最小值在转换为正值时会超出表达范围，因此用long long保存。

54.其实很简单的题。。。针对四个顶点进行循环，循环后进行更新，就是要注意几个细节，一是当只有一行或只有一列时会重复，还有当输入为空时注意访问会不会越界。还有insert的用法，v.insert(v.end(), tmp.begin(), tmp.end())。在v的最后插入tmp。

55.原理很简单，用DFS的方法做，可以最快的返回结果。注意的话递归的退出，用一个外部bool来判断是否继续。超时了是为什么。。。有一个例子没过。（忘了加visited数组了导致重复计算）

56.也是很简单的题目。注意分析特性就好，先进行排序，然后进行插入更新，若start小于等于end，则重合，进行更新，否则直接插入。

59.简单。。。也是旋转矩阵，同样利用四个顶点的更新来做。注意vector生成多维数组的方式。vector<vector<int>> ans; vector<int>tmp(n); ans.push_back(tmp); 或者申请后进行resize。vector<vector<int>> ans(n); while(i<n){ans[i++].resize()};

60.又是permutation，DFS递归做，最傻的方式就是从头开始遍历并计算次数，建立一个全局变量记录是否还需要继续递归。

61.链表，蛮简单的题目。就是要注意判断初始链表是否为空。一般都会用两个指针来解题。

62.求排列组合。第一反应是用DFS遍历所有结果，超时。发现规律可以用DP来做。自己多用例子进行推算比较容易发现规律。注意下初始化？memset(first, val, length)或者fill(first, last, val);

63.同第62基本一样，就是需要判断某个位置是否能“通过”，若不能通过则置0，状态转移方程依然为DFS[i][j]=DFS[i-1][j]+DFS[i][j-1]

64.与之前的题一样，也是动态规划的题，状态转移方程为dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]，但是要注意边界条件的初始化。此外还有vector的初始化，vector<int> tmp(len, val)

71.弱智题。。。就是不断的分类讨论即可。但是要注意string的操作，比如find, rfind, substr, erase。

73.第一想法是在原矩阵上进行标记，用不用的数字标记（如-1），但是结果输入范围是int。第二种方法就是将o(m+n)的方法进行改造，将原本需要的额外空间，放到第一列和第一行中。

74.有序矩阵中查找，用二分法，将在数组上的过程转化到矩阵中即可。注意边界条件，矩阵为空。

75.三种颜色排序。只要知道不断更新第一项队列和第三项队列即可。